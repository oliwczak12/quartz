{"/":{"title":"ü™¥ My digital garden ü™¥","content":"## **HEJüëã**\n\u003eTo m√≥j cyfrowy ogr√≥d w kt√≥rym znajdujƒÖ siƒô moje notatki ze studi√≥w.\n\n## Jak u≈ºywaƒáüíª\n\u003e**Jest kilka sposob√≥w na poruszanie siƒô po ogrodzie:**\n\n- Przechodzenie od nag≈Ç√≥wka do nag≈Ç√≥wka \n- Graf kt√≥ry zawsze znajduje siƒô na ko≈Ñcu stronyüìàüëá\n- Wyszukiwarkaüîç\n- Tagi znajdujƒÖce siƒô na poczƒÖtku ka≈ºdej notatkiüîùüìÑ\n## Notatkiüìô\n- ## [Notatki z I semestru](I%20semestr/I%20Semestr.md)\n- ## [Przedmioty II semestr](II%20Semestr/Przedmioty%20II%20semestr.md)\n\n## Todo list\n[Lista do zrobienia](Lista%20do%20zrobienia.md)\n","lastmodified":"2023-05-08T19:45:49.979496441Z","tags":null},"/I-semestr/Amzea/Analiza-matematyczna-z-elementami-algebry":{"title":"Amzea","content":"## Zagadnienia z przedmiotu\n\n### Zagadnienia do pierwszego kolokwium\n\n### Zagadnienia do drugiego kolokwium:\n\n- [Granica funkcji](I%20semestr/Amzea/II%20kolokwium/Granica%20funkcji.md)\n- ","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Amzea/Epsilon":{"title":"Epsilon","content":"\n## Wikipedia\noznaczenie dowolnie ma≈Çej liczby rzeczywistej dodatniej Œµ \u003e 0, czƒôsto stosowane w dowodach twierdze≈Ñ.\n\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Amzea/II-kolokwium/Granica-funkcji":{"title":"Granica funkcji","content":"\n\n## Sposoby obliczania\n- ## [Sprzƒô≈ºenie](I%20semestr/Amzea/II%20kolokwium/Sprzƒô≈ºenie.md)\n\n$$\n\\lim_{ x \\to 5 } \\frac{\\sqrt{ x-1}-2}{x-5}=\\left[ \\frac{0}{0} \\right]=\\lim_{ x \\to 5 } \\frac{\\sqrt{ x-1}-2}{x-5}\n$$\n\n- ## [Rozbicie ze wzor√≥w skr√≥conego mno≈ºenia](I%20semestr/Amzea/II%20kolokwium/Rozbicie%20ze%20wzor√≥w%20skr√≥conego%20mno≈ºenia.md)\n$$\n\\lim_{ x \\to 2 } \\frac{x^{2}-4 }{x-2}=\\lim_{ x \\to 2 } \\frac{\\cancel{(x-2)} (x+2)}{\\cancel{x-2}}=\\lim_{ x \\to 2 } x+2=4\n$$\n- Wzory\n   - $$\n\\lim_{ x \\to 0 } e^x=1\n$$\n$$\n\\arctan(\\infty)=\\frac{\\pi}{2}\n$$\n$$\ne^\\infty=\\infty\n$$\n$$\ne^{-\\infty}=0\n$$","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Amzea/II-kolokwium/Pochodne":{"title":"Pochodne","content":"\n$$\n(x^x)'= e^{x\\ln x}\n$$","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Amzea/II-kolokwium/Rozbicie-ze-wzor%C3%B3w-skr%C3%B3conego-mno%C5%BCenia":{"title":"Rozbicie ze wzor√≥w skr√≥conego mno≈ºenia","content":"\n$$\n\\lim_{ x \\to 2 } \\frac{x^{2}-4 }{x-2}=\\lim_{ x \\to 5 } \\frac{\\cancel{(x-2)} (x+2)}{\\cancel{x-2}}=\\lim_{ x \\to 5 } x+2=4\n$$\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Amzea/II-kolokwium/Sprz%C4%99%C5%BCenie":{"title":"Sprzƒô≈ºenie","content":"\n$$\n\\lim_{ x \\to 5 } \\frac{\\sqrt{ x-1}-2}{x-5}=\\left[ \\frac{0}{0} \\right]=\\lim_{ x \\to 5 } \\frac{\\sqrt{ x-1}-2}{x-5}\n$$","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/I-Semestr":{"title":"I Semestr","content":"## Przedmioty\n### [Wdi](I%20semestr/Wdi/Wdi.md)\n### [Amzea](I%20semestr/Amzea/Analiza%20matematyczna%20z%20elementami%20algebry.md)\n### [Programowanie](I%20semestr/Programowanie/Programowanie.md)\n\n\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/ASCII":{"title":"ASCII","content":"\n## Najpopularniejsze znaki \n\n![](Pasted%20image%2020230118221411.png)","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/Funkcjie-matematyczne":{"title":"Funkcjie matematyczne","content":"\n## Klasa Math\n\nImportowanie klasy Math\n```java\nimport static java.lang.Math.*;\n```\n\n### Przydatne sta≈Çe i metody \n\nMetody:\n\n```Java\nMath.sqrt(warto≈õc) - pierwiastek kwadratowy\nMath.pow(warto≈õƒá, potƒôga) - potƒôgowanie \n```\n\nSta≈Çe:\n\n```java\nMath.PI - warto≈õƒá liczby pi\n```\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/Programowanie":{"title":"Programowanie","content":"SƒÖ to dwa modu≈Çy ==Podstawy programowania== oraz ==Jƒôzyki programowania==\nsk≈ÇadajƒÖce sie z ƒáwicze≈Ñ i wyk≈Çad√≥w.\n\n## Zagadnienia \n- [Zapis do pliku](I%20semestr/Programowanie/Zapis%20do%20pliku.md)\n- [Tablice](I%20semestr/Programowanie/Tablice.md)\n- [Funkcjie matematyczne](I%20semestr/Programowanie/Funkcjie%20matematyczne.md)\n- [Przetwarzanie napis√≥w](I%20semestr/Programowanie/Przetwarzanie%20napis√≥w.md)\n- [ASCII](I%20semestr/Programowanie/ASCII.md)","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/Przetwarzanie-napis%C3%B3w":{"title":"Przetwarzanie napis√≥w","content":"\n## Wy≈õwietlanie znaku z tablicy po indeksie\n\ns≈Çu≈ºy do tego metoda charAt(index)\n\n```Java\nString str = \"Hello\"\nSystem.out.println(str.charAt(0)); //wy≈õwietla: H\nSystem.out.println(str.charAt(4)); //wy≈õwietla: o\n```\n\n## Zamiana wszystkich liter w ≈ÇƒÖ≈Ñcuchu na du≈ºe/ma≈Çe litery\n\ns≈Çu≈ºy do tego metoda toLowerCase()/toUpperCase()\n\n```Java \nString str1 = \"Panda\";\nString str2 = \"Dog\";\n\nSystem.out.println(str1.toLowerrCase()); //wy≈õwietla: panda\nSystem.out.println(str2.toUpperCase()); //wy≈õwietla: dog\n```\n\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/Tablice":{"title":"Tablice","content":"\n## Sposoby tworzenia tablic\n\n```java\ntyp[] nazwa_tablicy = new typ[liczba_element√≥w];\n```\n\n```Java\ntyp nazwa_tablicy[] = new typ[liczba_element√≥w];\n```\n\nMo≈ºemy r√≥wnie≈º stworzyƒá tablice odrazu jƒÖ inicjalizujƒÖc\n\n```java\ntyp[] tablica = {wartosc1, wartosc2, wartosc3, ...};\n```\n\n## Indeksowanie tablicy\n\nElementy tablicy indeksujemy od ==0== to znaczy ≈ºe pierwszy element ma indeks 0 drugi indeks 1 itd.\n\n## Przypisywanie warto≈õci do element√≥w tablicy \n\n```Java\nnazwa_tablicy[indeks] = warto≈õƒá;\n//Przyk≈Çad\nliczby[4] = 10;\n```\n\n## Por√≥wnywanie tablic\n\naby sprawdziƒá czy warto≈õci tablic w dw√≥ch tablicach sa sobie r√≥wne trzeba uzyc metody Arrays.equals().\n\n```Java\nimport java.util.Arrays;\n...\narr1[]={1,2,3};\narr2[]={1,2,3};\narr3[]={5,6,7};\n\nArrays.equals(arr1,arr2); //true\nArrays.equals(arr1,arr3); //false\n```\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/Zapis-do-pliku":{"title":"Zapis do pliku","content":"\n\n## Klasa RandomAccessFile\n konstruktor klasy: RandomAccessFile(\"nazwa pliku\", \"tryb\")\n tryby:\n  - rw - zapis/odczyt\n  - r - odczyt\n  - w - zapis\n \n metody:\n- zapis:\n    - writeUTF()\n    - writeInt()\n    - writeDouble()\n- odczyt\n    - readUTF()\n    - readInt()\n    - readDouble()","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Wdi/Automaty":{"title":"Automaty","content":"\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Wdi/Binarny/Dodawanie-i-odejmowanie":{"title":"Dodawanie i odejmowanie","content":"\n## TLDR\n- Kod ZM dodawanie/odejmowanie bez bitu znakowego. Bit znakowy wyniku okre≈õlaja znaki.\n- Kod ZU1 dodawanie/odejmowanie z bitem znakowym.\n\n## Dodawanie w [NKB](I%20semestr/Wdi/Zagadnienia/NKB.md)\nBinarnie dodajemy w s≈Çupku tak samo jak w systemie dziesietnym r√≥znica jest taka ≈ºe dodajemy kolejnƒÖ liczbe do nastƒôpnego rzƒôdu gdy liczba przekroczy jedynke a nie jak w systemie dziesietnym dziewiƒÖtke.\n\n\u003e[!example] Przyk≈Çad (nr.1)\n\u003e![](Pasted%20image%2020221230173721.png)\n\n## Dodawanie w kodzie [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md)\n\n1. ### Zamiana na ZM\n\u003e[!example] Przyk≈Çad (nr.2)\n\u003e\n\u003eA=-5\n\u003e\n\u003e![](Pasted%20image%2020221230190911.png)\n\u003e\n\u003eA=1.101\n\n\n2. ### Wyr√≥wnanie pozycji (niebieski)\n3. ### K + 1 Pozycji (zielony)\n\u003e[!example] Przyk≈Çad dla pkt 2 i 3 (nr.3)\n\u003e\n\u003eA=0.11 B=0.101\n\u003e\n\u003e![](Pasted%20image%2020221230191831.png)\n\n## Tabela znak√≥w\n\n|  Operacja   | Znaki liczb | Operacjia wykonywana | Po≈ºyczka  |            Znak wyniku             |\n|:-----------:|:-----------:|:--------------------:|:---------:|:----------------------------------:|\n|  Dodawanie  |    R√≥wne    |      Z = A + B       |    N/A    |  z\u003csub\u003en-1\u003c/sub\u003e=a\u003csub\u003en_1\u003c/sub\u003e   |\n|             |    R√≥≈ºne    |      Z = A - B       | Nie (w=0) |  z\u003csub\u003en-1\u003c/sub\u003e=a\u003csub\u003en_1\u003c/sub\u003e   |\n|             |             |                      | Tak (w=1) |  z\u003csub\u003en-1\u003c/sub\u003e=-a\u003csub\u003en_1\u003c/sub\u003e  |\n| Odejmowanie |    R√≥wne    |      Z = A - B       | Nie (w=0) |  z\u003csub\u003en-1\u003c/sub\u003e=a\u003csub\u003en_1\u003c/sub\u003e   |\n|             |             |                      | Tak (w=1) | z\u003csub\u003en-1\u003c/sub\u003e = -a\u003csub\u003en-1\u003c/sub\u003e |\n|             |    R√≥≈ºne    |      Z = A + B       |    N/A    |     z\u003csub\u003en-1\u003c/sub\u003e=a\u003csub\u003en_1\u003c/sub\u003e                                |\n## Odejmowanie w [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md)\nOdejmujemy tak samo jak w dziesiƒôtnym przy czym trzeba pamiƒôtaƒá ≈ºe je≈ºeli porzyczamy poza najstarszym bitem bierzemy \"po≈ºyczkƒô\" wp≈Çywa ona na znak jaki przydzielamy wynikowi. Znak okre≈õlamy przez Tabeli znak√≥w.\n\n\u003e[!warning] Uwaga!\n\u003e\n\u003eJe≈ºeli po≈ºyczka wynosi ==w=1== to wynik uzyskujemy w kodzie ==ZU2==\n\n\u003e[!example] Przyk≈Çad (nr.4)\n\u003e\n\u003eA=1.11 + B=0.101\n\u003e\n\u003e![](Pasted%20image%2020230102174827.png)\n\u003enegujemy znak (niebieski) poniewa≈º \"A\" jest na minusie oraz znaki sƒÖ r√≥≈ºne\n\n## Dodawanie w [ZU1](I%20semestr/Wdi/Zagadnienia/ZU1.md)\n\nW kodzie ZU1 dodajemy r√≥wnie≈º bity znakowe. Trzeba pamiƒôtaƒá o algorytmie przedstawionym w przyk≈Çadzie nr.5 kt√≥rym pos≈Çugujemy siƒô podczas wykonywania zadania. \n\n\u003e[!warning] Przyk≈Çad \n\u003e\n\u003eMo≈ºe r√≥wnie≈º wystƒÖpiƒá przepe≈Çnienie (ang. overflow) wtedy musimy dodaƒá jego warto≈õƒá do najmniej znaczƒÖcego bitu. Patrz przyk≈Çad nr.5\n\n\u003e[!example] Przyk≈Çad (nr.5)\n\u003e\n\u003eA=-3 B=5 \n\u003e\n\u003ezmianiamy na ZM: A=1.11\u003csub\u003eZM\u003c/sub\u003e B=0.101\u003csub\u003eZM\u003c/sub\u003e\n\u003e\n\u003edopisujemy zera z porzodu tak aby liczby mia≈Çy r√≥wnƒÖ liczbe bit√≥w oraz \"k+1\"\n\u003e\n\u003eA=1.0011\u003csub\u003eZM\u003c/sub\u003e B=0.0101\u003csub\u003eZM\u003c/sub\u003e\n\u003e\n\u003ezamianiamy na ZU1: A=1.1100\u003csub\u003eZU1\u003c/sub\u003e B=0.0101\u003csub\u003eZU1\u003c/sub\u003e\n\u003e\n\u003e![](Pasted%20image%2020230103194447.png)\n\u003e\n\u003ewynik zamieniamy z ZU1 na ZM: 0.0010\u003csub\u003eZM\u003c/sub\u003e\n\u003e\n\u003edekodujemy do dziesiƒôtnego: 2\n\n## Odejmowenie w ZU1\n\nW kodzie ZU1 odejmujemy wraz z bitami znakowymi. Algorytm na dekodowanie nie zmienia sie wzglƒôdem dodawania. Patrz przyk≈Çad nr.5\n\n\u003e[!warning] Uwaga\n\u003e\n\u003eJe≈ºeli wystƒÖpi po≈ºyczka odejmujemy jƒÖ od najmniej zaczƒÖcego bitu. Patrz przyk≈Çad nr.6\n\n\u003e[!example] Przyk≈Çad\n\u003e\n\u003eA=2 B=-6 \n\u003e\n\u003ezmianiamy na ZM: A=0.10\u003csub\u003eZM\u003c/sub\u003e B=1.110\u003csub\u003eZM\u003c/sub\u003e\n\u003e\n\u003edopisujemy zera z porzodu tak aby liczby mia≈Çy r√≥wnƒÖ liczbe bit√≥w oraz \"k+1\"\n\u003e\n\u003eA=0.0010\u003csub\u003eZM\u003c/sub\u003e B=1.0110\u003csub\u003eZM\u003c/sub\u003e\n\u003e\n\u003ezamianiamy na ZU1: A=0.0010\u003csub\u003eZU1\u003c/sub\u003e B=1.1001\u003csub\u003eZU1\u003c/sub\u003e\n\u003e\n\u003e![](Pasted%20image%2020230115175608.png)\n\n\n## Dodawanie w ZU2\n\nW ZU2 dodajemy z bitem znakowym je≈õli wystƒÖpi przepe≈Çnienie ignorujemy je.\n\n## Odejmowanie w ZU2\n\nW ZU2 odejmujemy z bitem znakowym je≈õli wystƒÖpi po≈ºyczka ignorujemy jƒÖ.\n\n\u003e[!note] Nastƒôpna notatka ‚áí \n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Binarny/Dzielenie":{"title":"Dzielenie","content":"\n## Metoda por√≥wnawcza\n\n\u003e[!info] Informacjie \n\u003e\n\u003eliczby zapisane sa w kodzie ZM\n\u003e\n\u003eoperacjie wykonuje sie na modu≈Çach liczb\n\u003e\n\u003epierwsza liczba jest ==dzielna== a druga ==dzielnik==\n\u003e\n\u003epierwsza liczba musi byƒá mniejsza od drugiej |A|\u003c|B|\n\n\u003e[!tldr] Algorytm\n\u003e\n\u003e1. Sprawdzamy warunek |A|\u003c|B|\u003c1\n\u003e2. Konwertujemy do kodu ZM\n\u003e3. przesuwamy o jedno miejsce w lewo\n\u003e4. sprawdzamy czy reszta po przesuniƒôciu jest wieksza bƒÖd≈∫ r√≥wna |B| czyli 2r\u003e=|B| je≈õli jest wiƒôksza to bit ilorazu (q\u003csub\u003en\u003c/sub\u003e) ustawiamy na \"1\" oraz odejmujemy od reszty dzielnik jesli jest mniejsza to bit ilorazu ustawiamy na \"0\"  \n\u003e5. przesuwamy o jedno miejsce w lewo powtarzamy krok 4 i piƒÖty a≈º nie dojdziemy do zera lub do dok≈Çadno≈õci do 7 miejsc po przecinku\n\u003e6. bity ilorazu (q) zczytane od g√≥ry dajƒÖ modu≈Ç wyniku\n\u003e7. sprawdzamy bit znakowy ilorazu q\u003csub\u003e0\u003c/sub\u003e =a\u003csub\u003e0\u003c/sub\u003e‚äïb\u003csub\u003e0\u003c/sub\u003e\n\u003e8. ≈ÇƒÖczymy znak z modu≈Çem\n\u003e9. dekodujemy\n \n\u003e[!example] Przyk≈Çad\n\u003e\n\u003e![](Pasted%20image%2020230204001949.png)\n\n## Metoda nierestytucyjna\n\n\u003e[!info] Informacjie\n\u003e\n\u003eliczby sa zapisane w kodzie ZU2\n\u003e\n\u003eobliczamy razem z bitem znakowym \n\u003e\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Binarny/Mno%C5%BCenie":{"title":"Mno≈ºenie","content":"\n## Mno≈ºenie\n\n\u003e[!info] info\n\u003e\n\u003epierwsza liczba to ==mno≈ºna==\n\u003e\n\u003edruga liczba to ==mno≈ºnik==\n\n### Both I\n\n\u003e[!note] Kroki\n\u003e\n\u003e 1. Konwersja - zamiana na ZU2\n\u003e 2. maskowanie - zostawiamy jedynie znak i czƒô≈õƒá u≈ÇamkowƒÖ\n\u003e 3. do mno≈ºnika dopisujemy 0 na najmniej znaczacej pozycji\n\u003e 4. obliczenia - korzystajƒÖc z tabelki okre≈õlamy czy odejmujemy czy dodajemy przy czym operacjie wykonujemy przez dodawanie/odejmowanie 0 od mno≈ºnej\n\u003e 5. u≈ºywajƒÖc tabelki analizujemy mno≈ºnik i na jego podstawie wykonujemy przesuniƒôcia i operacjie a≈º do ostatniej pary(razem z bitem znakowym) kt√≥rej nie przesuwamy ale wykonujemy operacjie \n\n\u003e[!tldr] Tabelka\n\u003e\n\u003e![](Pasted%20image%2020230203170432.png)\n\n\u003e[!example] Przyk≈Çad\n\u003e\n\u003e![](Pasted%20image%2020230203164304.png)\n\n### Both II\n\u003e[!info] Zmiany wzgledem pierwszej metody\n\u003e\n\u003ezmienia siƒô tabelka \n\u003eoraz zamiast dopisywaƒá 0 przesuwamy w prawo mno≈ºnƒÖ(pierwszƒÖ liczbe) \n\n\u003e[!tldr] Tabelka Both II\n\u003e\n\u003e![](Pasted%20image%2020230203193335.png)\n\n\u003e[!example] Przyk≈Çad\n\u003e\n\u003e![](Pasted%20image%2020230203193056.png)\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Cecha-i-mantysa":{"title":"Cecha i mantysa","content":"","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Dekodowanie/Dekodowanie":{"title":"Dekodowanie","content":"\n## Wz√≥r na dekodowanie NKB\n\n\u003e[!info] Wz√≥r\n\u003e\n\u003e$$\\displaystyle \\sum_{i=-m}^{n-1}a_{i} p^i$$\n\n### Wagi\n\n\u003e[!warning] Wagi\n\u003e\n\u003eIndeksujemy ka≈ºdy znak od prawej strony gdzie najm≈Çodszy znak zawsze ma indeks(wage) 0.\nZnaki po przecinku malejƒÖ w prawƒÖ strone a pierwszy znak ma indeks(wage) -1.\n$$1^3 1^2 1^1 0^0 ,1^{-1} 1^{-2}$$\n\n\u003e[!example] Przyk≈Çad zamiany systemu dw√≥jkowego na dziesiƒôtny\n\u003e\n\u003e$$(1110,11)_{2}=$$ $$1\\times2^3+1\\times2^2+1\\times2^1+0\\times2^0+1\\times2^{-1}+1\\times2^{-2}=$$\n\u003e\n\u003e$$8+4+1+1+\\frac{1}{2}+\\frac{1}{4}=(13,75)_{10}$$\n\n\n## Wz√≥r na dekodowanie z ZM na NKB\n\n\u003e[!info] Wz√≥r\n\u003e\n\u003e$$(1-2a_{n-1})\\displaystyle \\sum_{n=-m}^{n-2}a_{i}p^i=r(a_{n-1})\\displaystyle \\sum_{n=-m}^{n-2}a_{i}p^i$$\n\n\u003e[!warning] Uwaga\n\u003e\n\u003eW przypadku ZM bit znaku nie ma wagi.\n\n\u003e[!example] Przyk≈Çad zmiany z [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md) na dziesiƒôtny\n\u003e\n\u003e$$(1.1110,11)=-1\\times(1\\times2^3+1\\times2^2+1\\times2^1+0\\times2^0+1\\times2^{-1}+1\\times2^{-2})=$$\n\u003e\n\u003e$$=-\\left(8+4+1+1+\\frac{1}{2}+\\frac{1}{2} \\right)= -13,75$$\n\n## Wz√≥r na zamiane z NKB na system dziƒôsietny\n\n### Liczby ca≈Çkowite\nDzielimy przez 2 podanƒÖ liczbe dop√≥ki nie uzyskamy 1 przy czym wypisujemy reszte z dzielenia ka≈ºdej liczby za kreskƒÖ. Liczby uzyskane za kreska odczytujemy od do≈Çu uzysk√≥jƒÖc liczbe w NKB.\n\n\u003e[!example] Przyk≈Çad\n\u003e\n\u003e![](Pasted%20image%2020230115175912.png)\n\u003e\n\u003euzyskujemy (10111110)\u003csub\u003e2\u003c/sub\u003e\n\n### Liczby u≈Çamkowe\nW przypadku liczb u≈Çamkowych mno≈ºmy przez 2 oraz spisujemy uzyskanƒÖ liczbe od g√≥ry. Przy czym mamy 3 mo≈ºliwe przypadki:\n\n1. Zwyk≈Çy. Ko≈Ñczymy gdy wynikiem jest 0.\n\n\u003e[!example] Przyk≈Çad\n\u003e\n\u003e![](Pasted%20image%2020221227203907.png)\n\n\n\n2. W okresie. Mnozymy dop√≥ki nie uzyskamy warto≈õci kt√≥ra ju≈º wystapi≈Ça. Przy spisywaniu na poczatku spisujemy wszystkie warto≈õci przez okresem.\n\n\u003e[!example] Przyk≈Çad\n\u003e\n\u003e![](Pasted%20image%2020221227203332.png)\n\n\n\n\n3. Zwyk≈Çe \"d≈Çugie\". Mno≈ºenie nie ko≈Ñczy sie ani 0 ani okresem po 7 iteracjiach co zapisujemy jak na obrazku.\n\n\u003e[!example] Przyk≈Çad\n\u003e\n\u003e![](Pasted%20image%2020221227204246.png)\n\n### Zmiana system√≥w przez grupowanie \nGrupujemy liczbe po prawej i po lewej stonie przecinka w bloki o n-tej wielko≈õci kt√≥rƒÖ pozyskujemy ze wzoru ***q=p\u003csup\u003en\u003c/sup\u003e*** gdzie ***q*** to podstawa systemu na kt√≥ry zmieniamy a ***p*** to podstawa systemu kt√≥ry jest zmieniany.\n\n\u003e[!example] Przyk≈Çad\n![](Pasted%20image%2020221227223830.png)\n\n\u003e[!example] Przyk≈Çad\n\u003e\n\u003e![](Pasted%20image%2020230103210805.png)\n\n\n\n\n\n\n\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/ONP":{"title":"ONP","content":"\n## Odwrotna notacjia polska \n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Wdi":{"title":"Wdi","content":"\n## Zagadnienia\n- ### Zamiana system√≥w liczbowych\n -  [Dekodowanie](I%20semestr/Wdi/Dekodowanie/Dekodowanie.md)\n - [NKB](I%20semestr/Wdi/Zagadnienia/NKB.md)\n - [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md)\n - [ZU1](I%20semestr/Wdi/Zagadnienia/ZU1.md)\n - [ZU2](I%20semestr/Wdi/Zagadnienia/ZU2.md)\n- ### Algebra binarna\n -  [Dodawanie i odejmowanie](I%20semestr/Wdi/Binarny/Dodawanie%20i%20odejmowanie.md)\n - [Mno≈ºenie](I%20semestr/Wdi/Binarny/Mno≈ºenie.md)\n- [ONP](I%20semestr/Wdi/ONP.md) ","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Zagadnienia/NKB":{"title":"NKB","content":"","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Zagadnienia/ZM":{"title":"ZM","content":"Kod ==ZM== posiada bit znakowy kt√≥ry jest najstarszym bitem i ==oznacza znak +/-== . Do ==ZM== kodujemy przez zapisanie przez zapisanie bitu znakowego po czym zapisanie liczby w kodzie [NKB](I%20semestr/Wdi/Zagadnienia/NKB.md)\n\n\n\u003e[!info]  Wz√≥r na dekodowanie kodu ZM\n\u003e\n\u003e$$\n(1-2a_{n-1})\\displaystyle \\sum_{n=-m}^{n-2}a_{i}p^i=r(a_{n-1})\\displaystyle \\sum_{n=-m}^{n-2}a_{i}p^i\n$$\n\n\u003e [!example] Przyk≈Çad\n\u003e \n\u003e (5)\u003csub\u003e2\u003c/sub\u003e ‚áí (0.101)\u003csub\u003ezm\u003c/sub\u003e\n\u003e \n\u003e (-5)\u003csub\u003e2\u003c/sub\u003e ‚áí (1.101)\u003csub\u003ezm\u003c/sub\u003e \n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Zagadnienia/ZU1":{"title":"ZU1","content":"\nKod ==ZU1== posiada bit znakowy kt√≥ry jest najstarszym bitem i ==oznacza znak +/-== . Do ==ZU1== kodujemy przez zapisanie liczby w kodzie [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md) po czym:\n\n- ## W przypadku gdy bit znakowy jest r√≥wny ==0==\n\tprzepisujemy [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md)\n- ## W przypadku gdy bit znakowy jest r√≥wny ==1==\n\twszystkie liczby za bitem znakowym sƒÖ zanegowane 0 ‚áí 1 oraz 1 ‚áí 0. \n\nwszystkie liczby za znakiem sƒÖ zanegowane 0‚áí1 oraz 1‚áí0 . \n\n\u003e[!warning] Uwaga!!\n\u003e\n\u003eW ==ZU1== przydzielamy wage bitowi znakowemu\n\n\n\u003e [!example] Przyk≈Çad\n\u003e \n\u003e (5)\u003csub\u003e2\u003c/sub\u003e ‚áí (0.101)\u003csub\u003ezm\u003c/sub\u003e ‚áí (0.101)\u003csub\u003eZU1\u003c/sub\u003e \n\u003e \n\u003e (-5)\u003csub\u003e2\u003c/sub\u003e ‚áí (1.101)\u003csub\u003ezm\u003c/sub\u003e ‚áí (1.010)\u003csub\u003eZU1\u003c/sub\u003e \n\u003e\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Zagadnienia/ZU2":{"title":"ZU2","content":"\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Etapy-kompilacji":{"title":"Etapy kompilacji","content":"\n# Etapy\n\n1. Analiza leksykalna\n2. Analiza syntaktyczna\n3. Generacjia kodu","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Kompilacja-do-kodu-po%C5%9Bredniego":{"title":"Kompilacja do kodu po≈õredniego","content":"\nKompilator generuje [Kod po≈õredni](II%20Semestr/JPO/pojƒôcia/Kod%20po≈õredni.md) z kodu ≈∫r√≥d≈Çowego[^1] kt√≥ry to jest na bierzƒÖco przetwarzany przez wirtualny procesor[^2] do kodu maszynowego dla danego procesora. \n\n[^1]: [kod ≈∫r√≥d≈Çowy i kod wynikowy](II%20Semestr/JPO/pojƒôcia/kod%20≈∫r√≥d≈Çowy%20i%20kod%20wynikowy.md)\n[^2]: [Maszyna wirtualna](II%20Semestr/JPO/Maszyna%20wirtualna.md)\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Konsolidator":{"title":"Konsolidator","content":"\n# Konsolidator\n\nProgram ≈ÇƒÖczƒÖcy wszystkie elementy programu tworzƒÖcy odpowiedzni kod wykonywalny","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Maszyna-wirtualna":{"title":"Maszyna wirtualna","content":"\nJest to wirtualny procesor kt√≥ry przetwarza [Kod po≈õredni](II%20Semestr/JPO/pojƒôcia/Kod%20po≈õredni.md) kt√≥ry dostaje od kompilatora na konkretny predefiniowany procesor\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Popularne-j%C4%99zyki-programowania-a-metody-ich-translacji":{"title":"Popularne jƒôzyki programowania a metody ich translacji","content":"\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Preprocesor":{"title":"Preprocesor","content":"\nProgram kt√≥ry wstepnie przetwarza kod ≈∫r√≥d≈Çowy kt√≥ry wstƒôpnie przetwarza kod przed przekazaniem do kompilatora.","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Programowanie-obiektowe":{"title":"Programowanie obiektowe","content":"\n[zagadnienia I zer√≥wka](II%20Semestr/JPO/zagadnienia%20I%20zer√≥wka.md)\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Rodzaje-translacji-program%C3%B3w-komputerowych":{"title":"Rodzaje translacji program√≥w komputerowych","content":"\nProcesor przyjmuje instrukcje przekazane do niego jako zera i jedynki (kod maszynowy/≈∫r√≥d≈Çowy).\n\nKod wynikowy/maszynowy[^3]  jest wynikiem przetworzenia przez [Asembler](II%20Semestr/JPO/pojƒôcia/Asembler.md) jƒôzyka symbolicznego[^3] .\n\n# Sposoby zamiany kodu na kod maszynowy\n\n- ## Kompilator\n\n  generuje kod maszynowy dla danego procesora lub procesora wirtualnego[^2] r√≥≈ºni siƒô od asemblera tym ≈ºe kod piszemy tak samo dla r√≥≈ºnych platform\n  aczkolwiek do ka≈ºdej platformy dobieramy inny kompilator.\n\n  Kompilator przed wykonaniem kodu sprawdza jego poprawno≈õƒá.\n\n  Droga kodu ≈∫r√≥d≈Çowego do procesora\n\u003e[!info] Pierwsza opcja\n\u003e\n\u003e  kod ≈∫r√≥d≈Çowy =\u003e kompilator=\u003ekod maszynowy=\u003epamiƒôƒá operacyjna=\u003eprocesor \n\n\u003e[!info] Druga opcja\n\u003e\n\u003ekod ≈∫r√≥d≈Çowy =\u003e kompilator=\u003ekod po≈õredni=\u003emaszyna wirtualna=\u003ekod maszynowy=\u003epamiƒôƒá operacyjna=\u003eprocesor\n\n\n  pierwsza opcja jest szybsza lecz trudniejsza w utrzymaniu druga jest wolnijsza lecz prostsza w utrzymaniu\n\n  \u003e[!example] Przyk≈Çad\n  \u003e\n  \u003ec++\n  \u003e\n\n- ## Interpreter\n\n  W przypadku jƒôzyk√≥w interpretowanych interpreter t≈Çumaczy \u003cu\u003e***instrukcjie***\u003c/u\u003e[^1]\n  kodu ≈∫r√≥d≈Çowego robi to pojedy≈Ñczo instrukcja po instrukcji oraz na bierzƒÖco przez co mo≈ºe wykonaƒá niepoprawny kod do momentu a≈º sie nie wysypie.\n  \n\n\n\n[^1]: Prawid≈Çowa terminologia to instrukcjie nie linie\n[^2]: [Maszyna wirtualna](II%20Semestr/JPO/Maszyna%20wirtualna.md)\n[^3]: [kod ≈∫r√≥d≈Çowy i kod wynikowy](II%20Semestr/JPO/pojƒôcia/kod%20≈∫r√≥d≈Çowy%20i%20kod%20wynikowy.md)\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Rola-i-deklaracjia-funkcji-main":{"title":"Rola i deklaracjia funkcji main","content":"\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/poj%C4%99cia/Asembler":{"title":"Asembler","content":"\nTo program kt√≥ry t≈Çumaczy kod ≈∫r√≥d≈Çowy na kod wynikowy\n\n\nczyli proste komendy asemblera na zera i jedynki","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/poj%C4%99cia/J%C4%99zyk-wysokiego-poziomu":{"title":"Jƒôzyk wysokiego poziomu","content":"\nJezyk programowania kt√≥ry dzia≈Ça niezale≈ºnie od platformy pozwalajƒÖcy skupiƒá siƒô na logice eozwiƒÖzania problemu","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/poj%C4%99cia/Kod-po%C5%9Bredni":{"title":"Kod po≈õredni","content":"\nkod generowany przez kompilator jako kod dla [Maszyna wirtualna](II%20Semestr/JPO/Maszyna%20wirtualna.md)","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/poj%C4%99cia/Pami%C4%99%C4%87-operacyjna":{"title":"Pamiƒôc operacyjna","content":"\n\nAdresowane kom","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/poj%C4%99cia/kod-%C5%BAr%C3%B3d%C5%82owy-i-kod-wynikowy":{"title":"kod ≈∫r√≥d≈Çowy i kod wynikowy","content":"\n# Kod ≈∫r√≥d≈Çowy/jƒôzyk symboliczny\n\nkomendy kt√≥re moze wykonywaƒá procesor po uprzedni przekonwertowaniu ich na kod wynikowy/maszynowy\n\n# Kod wynikowy/maszynowy\n\nkod kt√≥ry procesor bezpo≈õrednio pobiera z [Pamiƒôƒá operacyjna](II%20Semestr/JPO/pojƒôcia/Pamiƒôƒá%20operacyjna.md) \n\n![](II%20Semestr/JPO/zdjƒôcia%20jpo/kod_zrodlowy_maszynowy.png)","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/zagadnienia-I-zer%C3%B3wka":{"title":"zagadnienia I zer√≥wka","content":"\n[Rodzaje translacji program√≥w komputerowych](II%20Semestr/JPO/Rodzaje%20translacji%20program√≥w%20komputerowych.md)\n\n[Kompilacja do kodu po≈õredniego](II%20Semestr/JPO/Kompilacja%20do%20kodu%20po≈õredniego.md)\n\n[[Maszyna wirtualna]]\n\n[Popularne jƒôzyki programowania a metody ich translacji](II%20Semestr/JPO/Popularne%20jƒôzyki%20programowania%20a%20metody%20ich%20translacji.md)\n\n[Etapy kompilacji](Etapy%20kompilacji)\n\n[[Preprocesor]]\n\n[Konsolidator](II%20Semestr/JPO/Konsolidator.md)\n\n[[Rola i deklaracjia funkcji main]]\n\n[[Deklarowanie zmiennych]]\n\n[[Zmienne klasy]]\n\n[[Auto]]\n\n[[Static]]\n\n[[Extern]]\n\n[[Proste typy danych]]\n\n[[Operatory arytmetyczne]]\n\n[[Podstawowe instrukcjie i pƒôtle]]\n\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/Mn/Metody-numeryczne":{"title":"Metody numeryczne","content":"\n\n","lastmodified":"2023-05-08T19:45:49.939496012Z","tags":null},"/II-Semestr/Mn/Teoria-b%C5%82%C4%99d%C3%B3w":{"title":"Teoria b≈Çƒôd√≥w","content":"","lastmodified":"2023-05-08T19:45:49.939496012Z","tags":null},"/II-Semestr/Przedmioty-II-semestr":{"title":"Przedmioty II semestr","content":"\n# [Metody numeryczne](II%20Semestr/Mn/Metody%20numeryczne.md)\n\n# [Programowanie obiektowe](II%20Semestr/JPO/Programowanie%20obiektowe.md)\n","lastmodified":"2023-05-08T19:45:49.939496012Z","tags":null},"/Lista-do-zrobienia":{"title":"Lista do zrobienia","content":"\n-  # Wdi\n    - [x] Dekodowanie\n    - [x] NKB\n    - [x] ZM\n    - [x] ZU1\n    - [ ] ZU2\n    - [ ] Dodawanie\n    - [ ] Odejmowanie\n    - [ ] Mno≈ºenie\n    - [ ] Dzielenie\n    - [ ] Maszyna touringa\n    - [ ] Automaty\n- # Amzea\n    - [ ] I kolos\n        - [ ] gof/fog\n    - [ ] II kolos\n        - [ ] Granice funkcji\n        - [ ] Pochodne\n\n\n\n\u003cstyle\u003e\ninput:disabled:checked{\nfilter: invert(55%) sepia(75%) saturate(2122%) hue-rotate(80deg) brightness(115%) contrast(126%);\n}\n\u003c/style\u003e\n\n\n","lastmodified":"2023-05-08T19:45:49.939496012Z","tags":null}}