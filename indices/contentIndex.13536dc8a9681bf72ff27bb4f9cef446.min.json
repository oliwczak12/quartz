{"/":{"title":"🪴 My digital garden 🪴","content":"## **HEJ👋**\n\u003eTo mój cyfrowy ogród w którym znajdują się moje notatki ze studiów.\n\n## Jak używać💻\n\u003e**Jest kilka sposobów na poruszanie się po ogrodzie:**\n\n- Przechodzenie od nagłówka do nagłówka \n- Graf który zawsze znajduje się na końcu strony📈👇\n- Wyszukiwarka🔍\n- Tagi znajdujące się na początku każdej notatki🔝📄\n## Notatki📙\n- ## [Notatki z I semestru](I%20semestr/I%20Semestr.md)\n- ## [Przedmioty II semestr](II%20Semestr/Przedmioty%20II%20semestr.md)\n\n## Todo list\n[Lista do zrobienia](Lista%20do%20zrobienia.md)\n","lastmodified":"2023-05-08T19:45:49.979496441Z","tags":null},"/I-semestr/Amzea/Analiza-matematyczna-z-elementami-algebry":{"title":"Amzea","content":"## Zagadnienia z przedmiotu\n\n### Zagadnienia do pierwszego kolokwium\n\n### Zagadnienia do drugiego kolokwium:\n\n- [Granica funkcji](I%20semestr/Amzea/II%20kolokwium/Granica%20funkcji.md)\n- ","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Amzea/Epsilon":{"title":"Epsilon","content":"\n## Wikipedia\noznaczenie dowolnie małej liczby rzeczywistej dodatniej ε \u003e 0, często stosowane w dowodach twierdzeń.\n\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Amzea/II-kolokwium/Granica-funkcji":{"title":"Granica funkcji","content":"\n\n## Sposoby obliczania\n- ## [Sprzężenie](I%20semestr/Amzea/II%20kolokwium/Sprzężenie.md)\n\n$$\n\\lim_{ x \\to 5 } \\frac{\\sqrt{ x-1}-2}{x-5}=\\left[ \\frac{0}{0} \\right]=\\lim_{ x \\to 5 } \\frac{\\sqrt{ x-1}-2}{x-5}\n$$\n\n- ## [Rozbicie ze wzorów skróconego mnożenia](I%20semestr/Amzea/II%20kolokwium/Rozbicie%20ze%20wzorów%20skróconego%20mnożenia.md)\n$$\n\\lim_{ x \\to 2 } \\frac{x^{2}-4 }{x-2}=\\lim_{ x \\to 2 } \\frac{\\cancel{(x-2)} (x+2)}{\\cancel{x-2}}=\\lim_{ x \\to 2 } x+2=4\n$$\n- Wzory\n   - $$\n\\lim_{ x \\to 0 } e^x=1\n$$\n$$\n\\arctan(\\infty)=\\frac{\\pi}{2}\n$$\n$$\ne^\\infty=\\infty\n$$\n$$\ne^{-\\infty}=0\n$$","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Amzea/II-kolokwium/Pochodne":{"title":"Pochodne","content":"\n$$\n(x^x)'= e^{x\\ln x}\n$$","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Amzea/II-kolokwium/Rozbicie-ze-wzor%C3%B3w-skr%C3%B3conego-mno%C5%BCenia":{"title":"Rozbicie ze wzorów skróconego mnożenia","content":"\n$$\n\\lim_{ x \\to 2 } \\frac{x^{2}-4 }{x-2}=\\lim_{ x \\to 5 } \\frac{\\cancel{(x-2)} (x+2)}{\\cancel{x-2}}=\\lim_{ x \\to 5 } x+2=4\n$$\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Amzea/II-kolokwium/Sprz%C4%99%C5%BCenie":{"title":"Sprzężenie","content":"\n$$\n\\lim_{ x \\to 5 } \\frac{\\sqrt{ x-1}-2}{x-5}=\\left[ \\frac{0}{0} \\right]=\\lim_{ x \\to 5 } \\frac{\\sqrt{ x-1}-2}{x-5}\n$$","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/I-Semestr":{"title":"I Semestr","content":"## Przedmioty\n### [Wdi](I%20semestr/Wdi/Wdi.md)\n### [Amzea](I%20semestr/Amzea/Analiza%20matematyczna%20z%20elementami%20algebry.md)\n### [Programowanie](I%20semestr/Programowanie/Programowanie.md)\n\n\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/ASCII":{"title":"ASCII","content":"\n## Najpopularniejsze znaki \n\n![](Pasted%20image%2020230118221411.png)","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/Funkcjie-matematyczne":{"title":"Funkcjie matematyczne","content":"\n## Klasa Math\n\nImportowanie klasy Math\n```java\nimport static java.lang.Math.*;\n```\n\n### Przydatne stałe i metody \n\nMetody:\n\n```Java\nMath.sqrt(wartośc) - pierwiastek kwadratowy\nMath.pow(wartość, potęga) - potęgowanie \n```\n\nStałe:\n\n```java\nMath.PI - wartość liczby pi\n```\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/Programowanie":{"title":"Programowanie","content":"Są to dwa moduły ==Podstawy programowania== oraz ==Języki programowania==\nskładające sie z ćwiczeń i wykładów.\n\n## Zagadnienia \n- [Zapis do pliku](I%20semestr/Programowanie/Zapis%20do%20pliku.md)\n- [Tablice](I%20semestr/Programowanie/Tablice.md)\n- [Funkcjie matematyczne](I%20semestr/Programowanie/Funkcjie%20matematyczne.md)\n- [Przetwarzanie napisów](I%20semestr/Programowanie/Przetwarzanie%20napisów.md)\n- [ASCII](I%20semestr/Programowanie/ASCII.md)","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/Przetwarzanie-napis%C3%B3w":{"title":"Przetwarzanie napisów","content":"\n## Wyświetlanie znaku z tablicy po indeksie\n\nsłuży do tego metoda charAt(index)\n\n```Java\nString str = \"Hello\"\nSystem.out.println(str.charAt(0)); //wyświetla: H\nSystem.out.println(str.charAt(4)); //wyświetla: o\n```\n\n## Zamiana wszystkich liter w łąńcuchu na duże/małe litery\n\nsłuży do tego metoda toLowerCase()/toUpperCase()\n\n```Java \nString str1 = \"Panda\";\nString str2 = \"Dog\";\n\nSystem.out.println(str1.toLowerrCase()); //wyświetla: panda\nSystem.out.println(str2.toUpperCase()); //wyświetla: dog\n```\n\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/Tablice":{"title":"Tablice","content":"\n## Sposoby tworzenia tablic\n\n```java\ntyp[] nazwa_tablicy = new typ[liczba_elementów];\n```\n\n```Java\ntyp nazwa_tablicy[] = new typ[liczba_elementów];\n```\n\nMożemy również stworzyć tablice odrazu ją inicjalizując\n\n```java\ntyp[] tablica = {wartosc1, wartosc2, wartosc3, ...};\n```\n\n## Indeksowanie tablicy\n\nElementy tablicy indeksujemy od ==0== to znaczy że pierwszy element ma indeks 0 drugi indeks 1 itd.\n\n## Przypisywanie wartości do elementów tablicy \n\n```Java\nnazwa_tablicy[indeks] = wartość;\n//Przykład\nliczby[4] = 10;\n```\n\n## Porównywanie tablic\n\naby sprawdzić czy wartości tablic w dwóch tablicach sa sobie równe trzeba uzyc metody Arrays.equals().\n\n```Java\nimport java.util.Arrays;\n...\narr1[]={1,2,3};\narr2[]={1,2,3};\narr3[]={5,6,7};\n\nArrays.equals(arr1,arr2); //true\nArrays.equals(arr1,arr3); //false\n```\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Programowanie/Zapis-do-pliku":{"title":"Zapis do pliku","content":"\n\n## Klasa RandomAccessFile\n konstruktor klasy: RandomAccessFile(\"nazwa pliku\", \"tryb\")\n tryby:\n  - rw - zapis/odczyt\n  - r - odczyt\n  - w - zapis\n \n metody:\n- zapis:\n    - writeUTF()\n    - writeInt()\n    - writeDouble()\n- odczyt\n    - readUTF()\n    - readInt()\n    - readDouble()","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Wdi/Automaty":{"title":"Automaty","content":"\n","lastmodified":"2023-05-08T19:45:49.931495926Z","tags":null},"/I-semestr/Wdi/Binarny/Dodawanie-i-odejmowanie":{"title":"Dodawanie i odejmowanie","content":"\n## TLDR\n- Kod ZM dodawanie/odejmowanie bez bitu znakowego. Bit znakowy wyniku określaja znaki.\n- Kod ZU1 dodawanie/odejmowanie z bitem znakowym.\n\n## Dodawanie w [NKB](I%20semestr/Wdi/Zagadnienia/NKB.md)\nBinarnie dodajemy w słupku tak samo jak w systemie dziesietnym róznica jest taka że dodajemy kolejną liczbe do następnego rzędu gdy liczba przekroczy jedynke a nie jak w systemie dziesietnym dziewiątke.\n\n\u003e[!example] Przykład (nr.1)\n\u003e![](Pasted%20image%2020221230173721.png)\n\n## Dodawanie w kodzie [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md)\n\n1. ### Zamiana na ZM\n\u003e[!example] Przykład (nr.2)\n\u003e\n\u003eA=-5\n\u003e\n\u003e![](Pasted%20image%2020221230190911.png)\n\u003e\n\u003eA=1.101\n\n\n2. ### Wyrównanie pozycji (niebieski)\n3. ### K + 1 Pozycji (zielony)\n\u003e[!example] Przykład dla pkt 2 i 3 (nr.3)\n\u003e\n\u003eA=0.11 B=0.101\n\u003e\n\u003e![](Pasted%20image%2020221230191831.png)\n\n## Tabela znaków\n\n|  Operacja   | Znaki liczb | Operacjia wykonywana | Pożyczka  |            Znak wyniku             |\n|:-----------:|:-----------:|:--------------------:|:---------:|:----------------------------------:|\n|  Dodawanie  |    Równe    |      Z = A + B       |    N/A    |  z\u003csub\u003en-1\u003c/sub\u003e=a\u003csub\u003en_1\u003c/sub\u003e   |\n|             |    Różne    |      Z = A - B       | Nie (w=0) |  z\u003csub\u003en-1\u003c/sub\u003e=a\u003csub\u003en_1\u003c/sub\u003e   |\n|             |             |                      | Tak (w=1) |  z\u003csub\u003en-1\u003c/sub\u003e=-a\u003csub\u003en_1\u003c/sub\u003e  |\n| Odejmowanie |    Równe    |      Z = A - B       | Nie (w=0) |  z\u003csub\u003en-1\u003c/sub\u003e=a\u003csub\u003en_1\u003c/sub\u003e   |\n|             |             |                      | Tak (w=1) | z\u003csub\u003en-1\u003c/sub\u003e = -a\u003csub\u003en-1\u003c/sub\u003e |\n|             |    Różne    |      Z = A + B       |    N/A    |     z\u003csub\u003en-1\u003c/sub\u003e=a\u003csub\u003en_1\u003c/sub\u003e                                |\n## Odejmowanie w [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md)\nOdejmujemy tak samo jak w dziesiętnym przy czym trzeba pamiętać że jeżeli porzyczamy poza najstarszym bitem bierzemy \"pożyczkę\" wpływa ona na znak jaki przydzielamy wynikowi. Znak określamy przez Tabeli znaków.\n\n\u003e[!warning] Uwaga!\n\u003e\n\u003eJeżeli pożyczka wynosi ==w=1== to wynik uzyskujemy w kodzie ==ZU2==\n\n\u003e[!example] Przykład (nr.4)\n\u003e\n\u003eA=1.11 + B=0.101\n\u003e\n\u003e![](Pasted%20image%2020230102174827.png)\n\u003enegujemy znak (niebieski) ponieważ \"A\" jest na minusie oraz znaki są różne\n\n## Dodawanie w [ZU1](I%20semestr/Wdi/Zagadnienia/ZU1.md)\n\nW kodzie ZU1 dodajemy również bity znakowe. Trzeba pamiętać o algorytmie przedstawionym w przykładzie nr.5 którym posługujemy się podczas wykonywania zadania. \n\n\u003e[!warning] Przykład \n\u003e\n\u003eMoże również wystąpić przepełnienie (ang. overflow) wtedy musimy dodać jego wartość do najmniej znaczącego bitu. Patrz przykład nr.5\n\n\u003e[!example] Przykład (nr.5)\n\u003e\n\u003eA=-3 B=5 \n\u003e\n\u003ezmianiamy na ZM: A=1.11\u003csub\u003eZM\u003c/sub\u003e B=0.101\u003csub\u003eZM\u003c/sub\u003e\n\u003e\n\u003edopisujemy zera z porzodu tak aby liczby miały równą liczbe bitów oraz \"k+1\"\n\u003e\n\u003eA=1.0011\u003csub\u003eZM\u003c/sub\u003e B=0.0101\u003csub\u003eZM\u003c/sub\u003e\n\u003e\n\u003ezamianiamy na ZU1: A=1.1100\u003csub\u003eZU1\u003c/sub\u003e B=0.0101\u003csub\u003eZU1\u003c/sub\u003e\n\u003e\n\u003e![](Pasted%20image%2020230103194447.png)\n\u003e\n\u003ewynik zamieniamy z ZU1 na ZM: 0.0010\u003csub\u003eZM\u003c/sub\u003e\n\u003e\n\u003edekodujemy do dziesiętnego: 2\n\n## Odejmowenie w ZU1\n\nW kodzie ZU1 odejmujemy wraz z bitami znakowymi. Algorytm na dekodowanie nie zmienia sie względem dodawania. Patrz przykład nr.5\n\n\u003e[!warning] Uwaga\n\u003e\n\u003eJeżeli wystąpi pożyczka odejmujemy ją od najmniej zaczącego bitu. Patrz przykład nr.6\n\n\u003e[!example] Przykład\n\u003e\n\u003eA=2 B=-6 \n\u003e\n\u003ezmianiamy na ZM: A=0.10\u003csub\u003eZM\u003c/sub\u003e B=1.110\u003csub\u003eZM\u003c/sub\u003e\n\u003e\n\u003edopisujemy zera z porzodu tak aby liczby miały równą liczbe bitów oraz \"k+1\"\n\u003e\n\u003eA=0.0010\u003csub\u003eZM\u003c/sub\u003e B=1.0110\u003csub\u003eZM\u003c/sub\u003e\n\u003e\n\u003ezamianiamy na ZU1: A=0.0010\u003csub\u003eZU1\u003c/sub\u003e B=1.1001\u003csub\u003eZU1\u003c/sub\u003e\n\u003e\n\u003e![](Pasted%20image%2020230115175608.png)\n\n\n## Dodawanie w ZU2\n\nW ZU2 dodajemy z bitem znakowym jeśli wystąpi przepełnienie ignorujemy je.\n\n## Odejmowanie w ZU2\n\nW ZU2 odejmujemy z bitem znakowym jeśli wystąpi pożyczka ignorujemy ją.\n\n\u003e[!note] Następna notatka ⇒ \n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Binarny/Dzielenie":{"title":"Dzielenie","content":"\n## Metoda porównawcza\n\n\u003e[!info] Informacjie \n\u003e\n\u003eliczby zapisane sa w kodzie ZM\n\u003e\n\u003eoperacjie wykonuje sie na modułach liczb\n\u003e\n\u003epierwsza liczba jest ==dzielna== a druga ==dzielnik==\n\u003e\n\u003epierwsza liczba musi być mniejsza od drugiej |A|\u003c|B|\n\n\u003e[!tldr] Algorytm\n\u003e\n\u003e1. Sprawdzamy warunek |A|\u003c|B|\u003c1\n\u003e2. Konwertujemy do kodu ZM\n\u003e3. przesuwamy o jedno miejsce w lewo\n\u003e4. sprawdzamy czy reszta po przesunięciu jest wieksza bądź równa |B| czyli 2r\u003e=|B| jeśli jest większa to bit ilorazu (q\u003csub\u003en\u003c/sub\u003e) ustawiamy na \"1\" oraz odejmujemy od reszty dzielnik jesli jest mniejsza to bit ilorazu ustawiamy na \"0\"  \n\u003e5. przesuwamy o jedno miejsce w lewo powtarzamy krok 4 i piąty aż nie dojdziemy do zera lub do dokładności do 7 miejsc po przecinku\n\u003e6. bity ilorazu (q) zczytane od góry dają moduł wyniku\n\u003e7. sprawdzamy bit znakowy ilorazu q\u003csub\u003e0\u003c/sub\u003e =a\u003csub\u003e0\u003c/sub\u003e⊕b\u003csub\u003e0\u003c/sub\u003e\n\u003e8. łączymy znak z modułem\n\u003e9. dekodujemy\n \n\u003e[!example] Przykład\n\u003e\n\u003e![](Pasted%20image%2020230204001949.png)\n\n## Metoda nierestytucyjna\n\n\u003e[!info] Informacjie\n\u003e\n\u003eliczby sa zapisane w kodzie ZU2\n\u003e\n\u003eobliczamy razem z bitem znakowym \n\u003e\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Binarny/Mno%C5%BCenie":{"title":"Mnożenie","content":"\n## Mnożenie\n\n\u003e[!info] info\n\u003e\n\u003epierwsza liczba to ==mnożna==\n\u003e\n\u003edruga liczba to ==mnożnik==\n\n### Both I\n\n\u003e[!note] Kroki\n\u003e\n\u003e 1. Konwersja - zamiana na ZU2\n\u003e 2. maskowanie - zostawiamy jedynie znak i część ułamkową\n\u003e 3. do mnożnika dopisujemy 0 na najmniej znaczacej pozycji\n\u003e 4. obliczenia - korzystając z tabelki określamy czy odejmujemy czy dodajemy przy czym operacjie wykonujemy przez dodawanie/odejmowanie 0 od mnożnej\n\u003e 5. używając tabelki analizujemy mnożnik i na jego podstawie wykonujemy przesunięcia i operacjie aż do ostatniej pary(razem z bitem znakowym) której nie przesuwamy ale wykonujemy operacjie \n\n\u003e[!tldr] Tabelka\n\u003e\n\u003e![](Pasted%20image%2020230203170432.png)\n\n\u003e[!example] Przykład\n\u003e\n\u003e![](Pasted%20image%2020230203164304.png)\n\n### Both II\n\u003e[!info] Zmiany wzgledem pierwszej metody\n\u003e\n\u003ezmienia się tabelka \n\u003eoraz zamiast dopisywać 0 przesuwamy w prawo mnożną(pierwszą liczbe) \n\n\u003e[!tldr] Tabelka Both II\n\u003e\n\u003e![](Pasted%20image%2020230203193335.png)\n\n\u003e[!example] Przykład\n\u003e\n\u003e![](Pasted%20image%2020230203193056.png)\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Cecha-i-mantysa":{"title":"Cecha i mantysa","content":"","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Dekodowanie/Dekodowanie":{"title":"Dekodowanie","content":"\n## Wzór na dekodowanie NKB\n\n\u003e[!info] Wzór\n\u003e\n\u003e$$\\displaystyle \\sum_{i=-m}^{n-1}a_{i} p^i$$\n\n### Wagi\n\n\u003e[!warning] Wagi\n\u003e\n\u003eIndeksujemy każdy znak od prawej strony gdzie najmłodszy znak zawsze ma indeks(wage) 0.\nZnaki po przecinku maleją w prawą strone a pierwszy znak ma indeks(wage) -1.\n$$1^3 1^2 1^1 0^0 ,1^{-1} 1^{-2}$$\n\n\u003e[!example] Przykład zamiany systemu dwójkowego na dziesiętny\n\u003e\n\u003e$$(1110,11)_{2}=$$ $$1\\times2^3+1\\times2^2+1\\times2^1+0\\times2^0+1\\times2^{-1}+1\\times2^{-2}=$$\n\u003e\n\u003e$$8+4+1+1+\\frac{1}{2}+\\frac{1}{4}=(13,75)_{10}$$\n\n\n## Wzór na dekodowanie z ZM na NKB\n\n\u003e[!info] Wzór\n\u003e\n\u003e$$(1-2a_{n-1})\\displaystyle \\sum_{n=-m}^{n-2}a_{i}p^i=r(a_{n-1})\\displaystyle \\sum_{n=-m}^{n-2}a_{i}p^i$$\n\n\u003e[!warning] Uwaga\n\u003e\n\u003eW przypadku ZM bit znaku nie ma wagi.\n\n\u003e[!example] Przykład zmiany z [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md) na dziesiętny\n\u003e\n\u003e$$(1.1110,11)=-1\\times(1\\times2^3+1\\times2^2+1\\times2^1+0\\times2^0+1\\times2^{-1}+1\\times2^{-2})=$$\n\u003e\n\u003e$$=-\\left(8+4+1+1+\\frac{1}{2}+\\frac{1}{2} \\right)= -13,75$$\n\n## Wzór na zamiane z NKB na system dzięsietny\n\n### Liczby całkowite\nDzielimy przez 2 podaną liczbe dopóki nie uzyskamy 1 przy czym wypisujemy reszte z dzielenia każdej liczby za kreską. Liczby uzyskane za kreska odczytujemy od dołu uzyskójąc liczbe w NKB.\n\n\u003e[!example] Przykład\n\u003e\n\u003e![](Pasted%20image%2020230115175912.png)\n\u003e\n\u003euzyskujemy (10111110)\u003csub\u003e2\u003c/sub\u003e\n\n### Liczby ułamkowe\nW przypadku liczb ułamkowych mnożmy przez 2 oraz spisujemy uzyskaną liczbe od góry. Przy czym mamy 3 możliwe przypadki:\n\n1. Zwykły. Kończymy gdy wynikiem jest 0.\n\n\u003e[!example] Przykład\n\u003e\n\u003e![](Pasted%20image%2020221227203907.png)\n\n\n\n2. W okresie. Mnozymy dopóki nie uzyskamy wartości która już wystapiła. Przy spisywaniu na poczatku spisujemy wszystkie wartości przez okresem.\n\n\u003e[!example] Przykład\n\u003e\n\u003e![](Pasted%20image%2020221227203332.png)\n\n\n\n\n3. Zwykłe \"długie\". Mnożenie nie kończy sie ani 0 ani okresem po 7 iteracjiach co zapisujemy jak na obrazku.\n\n\u003e[!example] Przykład\n\u003e\n\u003e![](Pasted%20image%2020221227204246.png)\n\n### Zmiana systemów przez grupowanie \nGrupujemy liczbe po prawej i po lewej stonie przecinka w bloki o n-tej wielkości którą pozyskujemy ze wzoru ***q=p\u003csup\u003en\u003c/sup\u003e*** gdzie ***q*** to podstawa systemu na który zmieniamy a ***p*** to podstawa systemu który jest zmieniany.\n\n\u003e[!example] Przykład\n![](Pasted%20image%2020221227223830.png)\n\n\u003e[!example] Przykład\n\u003e\n\u003e![](Pasted%20image%2020230103210805.png)\n\n\n\n\n\n\n\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/ONP":{"title":"ONP","content":"\n## Odwrotna notacjia polska \n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Wdi":{"title":"Wdi","content":"\n## Zagadnienia\n- ### Zamiana systemów liczbowych\n -  [Dekodowanie](I%20semestr/Wdi/Dekodowanie/Dekodowanie.md)\n - [NKB](I%20semestr/Wdi/Zagadnienia/NKB.md)\n - [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md)\n - [ZU1](I%20semestr/Wdi/Zagadnienia/ZU1.md)\n - [ZU2](I%20semestr/Wdi/Zagadnienia/ZU2.md)\n- ### Algebra binarna\n -  [Dodawanie i odejmowanie](I%20semestr/Wdi/Binarny/Dodawanie%20i%20odejmowanie.md)\n - [Mnożenie](I%20semestr/Wdi/Binarny/Mnożenie.md)\n- [ONP](I%20semestr/Wdi/ONP.md) ","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Zagadnienia/NKB":{"title":"NKB","content":"","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Zagadnienia/ZM":{"title":"ZM","content":"Kod ==ZM== posiada bit znakowy który jest najstarszym bitem i ==oznacza znak +/-== . Do ==ZM== kodujemy przez zapisanie przez zapisanie bitu znakowego po czym zapisanie liczby w kodzie [NKB](I%20semestr/Wdi/Zagadnienia/NKB.md)\n\n\n\u003e[!info]  Wzór na dekodowanie kodu ZM\n\u003e\n\u003e$$\n(1-2a_{n-1})\\displaystyle \\sum_{n=-m}^{n-2}a_{i}p^i=r(a_{n-1})\\displaystyle \\sum_{n=-m}^{n-2}a_{i}p^i\n$$\n\n\u003e [!example] Przykład\n\u003e \n\u003e (5)\u003csub\u003e2\u003c/sub\u003e ⇒ (0.101)\u003csub\u003ezm\u003c/sub\u003e\n\u003e \n\u003e (-5)\u003csub\u003e2\u003c/sub\u003e ⇒ (1.101)\u003csub\u003ezm\u003c/sub\u003e \n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Zagadnienia/ZU1":{"title":"ZU1","content":"\nKod ==ZU1== posiada bit znakowy który jest najstarszym bitem i ==oznacza znak +/-== . Do ==ZU1== kodujemy przez zapisanie liczby w kodzie [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md) po czym:\n\n- ## W przypadku gdy bit znakowy jest równy ==0==\n\tprzepisujemy [ZM](I%20semestr/Wdi/Zagadnienia/ZM.md)\n- ## W przypadku gdy bit znakowy jest równy ==1==\n\twszystkie liczby za bitem znakowym są zanegowane 0 ⇒ 1 oraz 1 ⇒ 0. \n\nwszystkie liczby za znakiem są zanegowane 0⇒1 oraz 1⇒0 . \n\n\u003e[!warning] Uwaga!!\n\u003e\n\u003eW ==ZU1== przydzielamy wage bitowi znakowemu\n\n\n\u003e [!example] Przykład\n\u003e \n\u003e (5)\u003csub\u003e2\u003c/sub\u003e ⇒ (0.101)\u003csub\u003ezm\u003c/sub\u003e ⇒ (0.101)\u003csub\u003eZU1\u003c/sub\u003e \n\u003e \n\u003e (-5)\u003csub\u003e2\u003c/sub\u003e ⇒ (1.101)\u003csub\u003ezm\u003c/sub\u003e ⇒ (1.010)\u003csub\u003eZU1\u003c/sub\u003e \n\u003e\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/I-semestr/Wdi/Zagadnienia/ZU2":{"title":"ZU2","content":"\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Etapy-kompilacji":{"title":"Etapy kompilacji","content":"\n# Etapy\n\n1. Analiza leksykalna\n2. Analiza syntaktyczna\n3. Generacjia kodu","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Kompilacja-do-kodu-po%C5%9Bredniego":{"title":"Kompilacja do kodu pośredniego","content":"\nKompilator generuje [Kod pośredni](II%20Semestr/JPO/pojęcia/Kod%20pośredni.md) z kodu źródłowego[^1] który to jest na bierząco przetwarzany przez wirtualny procesor[^2] do kodu maszynowego dla danego procesora. \n\n[^1]: [kod źródłowy i kod wynikowy](II%20Semestr/JPO/pojęcia/kod%20źródłowy%20i%20kod%20wynikowy.md)\n[^2]: [Maszyna wirtualna](II%20Semestr/JPO/Maszyna%20wirtualna.md)\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Konsolidator":{"title":"Konsolidator","content":"\n# Konsolidator\n\nProgram łączący wszystkie elementy programu tworzący odpowiedzni kod wykonywalny","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Maszyna-wirtualna":{"title":"Maszyna wirtualna","content":"\nJest to wirtualny procesor który przetwarza [Kod pośredni](II%20Semestr/JPO/pojęcia/Kod%20pośredni.md) który dostaje od kompilatora na konkretny predefiniowany procesor\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Popularne-j%C4%99zyki-programowania-a-metody-ich-translacji":{"title":"Popularne języki programowania a metody ich translacji","content":"\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Preprocesor":{"title":"Preprocesor","content":"\nProgram który wstepnie przetwarza kod źródłowy który wstępnie przetwarza kod przed przekazaniem do kompilatora.","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Programowanie-obiektowe":{"title":"Programowanie obiektowe","content":"\n[zagadnienia I zerówka](II%20Semestr/JPO/zagadnienia%20I%20zerówka.md)\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Rodzaje-translacji-program%C3%B3w-komputerowych":{"title":"Rodzaje translacji programów komputerowych","content":"\nProcesor przyjmuje instrukcje przekazane do niego jako zera i jedynki (kod maszynowy/źródłowy).\n\nKod wynikowy/maszynowy[^3]  jest wynikiem przetworzenia przez [Asembler](II%20Semestr/JPO/pojęcia/Asembler.md) języka symbolicznego[^3] .\n\n# Sposoby zamiany kodu na kod maszynowy\n\n- ## Kompilator\n\n  generuje kod maszynowy dla danego procesora lub procesora wirtualnego[^2] różni się od asemblera tym że kod piszemy tak samo dla różnych platform\n  aczkolwiek do każdej platformy dobieramy inny kompilator.\n\n  Kompilator przed wykonaniem kodu sprawdza jego poprawność.\n\n  Droga kodu źródłowego do procesora\n\u003e[!info] Pierwsza opcja\n\u003e\n\u003e  kod źródłowy =\u003e kompilator=\u003ekod maszynowy=\u003epamięć operacyjna=\u003eprocesor \n\n\u003e[!info] Druga opcja\n\u003e\n\u003ekod źródłowy =\u003e kompilator=\u003ekod pośredni=\u003emaszyna wirtualna=\u003ekod maszynowy=\u003epamięć operacyjna=\u003eprocesor\n\n\n  pierwsza opcja jest szybsza lecz trudniejsza w utrzymaniu druga jest wolnijsza lecz prostsza w utrzymaniu\n\n  \u003e[!example] Przykład\n  \u003e\n  \u003ec++\n  \u003e\n\n- ## Interpreter\n\n  W przypadku języków interpretowanych interpreter tłumaczy \u003cu\u003e***instrukcjie***\u003c/u\u003e[^1]\n  kodu źródłowego robi to pojedyńczo instrukcja po instrukcji oraz na bierząco przez co może wykonać niepoprawny kod do momentu aż sie nie wysypie.\n  \n\n\n\n[^1]: Prawidłowa terminologia to instrukcjie nie linie\n[^2]: [Maszyna wirtualna](II%20Semestr/JPO/Maszyna%20wirtualna.md)\n[^3]: [kod źródłowy i kod wynikowy](II%20Semestr/JPO/pojęcia/kod%20źródłowy%20i%20kod%20wynikowy.md)\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/Rola-i-deklaracjia-funkcji-main":{"title":"Rola i deklaracjia funkcji main","content":"\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/poj%C4%99cia/Asembler":{"title":"Asembler","content":"\nTo program który tłumaczy kod źródłowy na kod wynikowy\n\n\nczyli proste komendy asemblera na zera i jedynki","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/poj%C4%99cia/J%C4%99zyk-wysokiego-poziomu":{"title":"Język wysokiego poziomu","content":"\nJezyk programowania który działa niezależnie od platformy pozwalający skupić się na logice eozwiązania problemu","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/poj%C4%99cia/Kod-po%C5%9Bredni":{"title":"Kod pośredni","content":"\nkod generowany przez kompilator jako kod dla [Maszyna wirtualna](II%20Semestr/JPO/Maszyna%20wirtualna.md)","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/poj%C4%99cia/Pami%C4%99%C4%87-operacyjna":{"title":"Pamięc operacyjna","content":"\n\nAdresowane kom","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/poj%C4%99cia/kod-%C5%BAr%C3%B3d%C5%82owy-i-kod-wynikowy":{"title":"kod źródłowy i kod wynikowy","content":"\n# Kod źródłowy/język symboliczny\n\nkomendy które moze wykonywać procesor po uprzedni przekonwertowaniu ich na kod wynikowy/maszynowy\n\n# Kod wynikowy/maszynowy\n\nkod który procesor bezpośrednio pobiera z [Pamięć operacyjna](II%20Semestr/JPO/pojęcia/Pamięć%20operacyjna.md) \n\n![](II%20Semestr/JPO/zdjęcia%20jpo/kod_zrodlowy_maszynowy.png)","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/JPO/zagadnienia-I-zer%C3%B3wka":{"title":"zagadnienia I zerówka","content":"\n[Rodzaje translacji programów komputerowych](II%20Semestr/JPO/Rodzaje%20translacji%20programów%20komputerowych.md)\n\n[Kompilacja do kodu pośredniego](II%20Semestr/JPO/Kompilacja%20do%20kodu%20pośredniego.md)\n\n[[Maszyna wirtualna]]\n\n[Popularne języki programowania a metody ich translacji](II%20Semestr/JPO/Popularne%20języki%20programowania%20a%20metody%20ich%20translacji.md)\n\n[Etapy kompilacji](Etapy%20kompilacji)\n\n[[Preprocesor]]\n\n[Konsolidator](II%20Semestr/JPO/Konsolidator.md)\n\n[[Rola i deklaracjia funkcji main]]\n\n[[Deklarowanie zmiennych]]\n\n[[Zmienne klasy]]\n\n[[Auto]]\n\n[[Static]]\n\n[[Extern]]\n\n[[Proste typy danych]]\n\n[[Operatory arytmetyczne]]\n\n[[Podstawowe instrukcjie i pętle]]\n\n\n","lastmodified":"2023-05-08T19:45:49.935495969Z","tags":null},"/II-Semestr/Mn/Metody-numeryczne":{"title":"Metody numeryczne","content":"\n\n","lastmodified":"2023-05-08T19:45:49.939496012Z","tags":null},"/II-Semestr/Mn/Teoria-b%C5%82%C4%99d%C3%B3w":{"title":"Teoria błędów","content":"","lastmodified":"2023-05-08T19:45:49.939496012Z","tags":null},"/II-Semestr/Przedmioty-II-semestr":{"title":"Przedmioty II semestr","content":"\n# [Metody numeryczne](II%20Semestr/Mn/Metody%20numeryczne.md)\n\n# [Programowanie obiektowe](II%20Semestr/JPO/Programowanie%20obiektowe.md)\n","lastmodified":"2023-05-08T19:45:49.939496012Z","tags":null},"/Lista-do-zrobienia":{"title":"Lista do zrobienia","content":"\n-  # Wdi\n    - [x] Dekodowanie\n    - [x] NKB\n    - [x] ZM\n    - [x] ZU1\n    - [ ] ZU2\n    - [ ] Dodawanie\n    - [ ] Odejmowanie\n    - [ ] Mnożenie\n    - [ ] Dzielenie\n    - [ ] Maszyna touringa\n    - [ ] Automaty\n- # Amzea\n    - [ ] I kolos\n        - [ ] gof/fog\n    - [ ] II kolos\n        - [ ] Granice funkcji\n        - [ ] Pochodne\n\n\n\n\u003cstyle\u003e\ninput:disabled:checked{\nfilter: invert(55%) sepia(75%) saturate(2122%) hue-rotate(80deg) brightness(115%) contrast(126%);\n}\n\u003c/style\u003e\n\n\n","lastmodified":"2023-05-08T19:45:49.939496012Z","tags":null}}